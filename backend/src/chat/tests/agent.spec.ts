import * as fs from 'fs';
import * as path from 'path';
import * as request from 'supertest';
import { Test } from '@nestjs/testing';
import { INestApplication, Logger } from '@nestjs/common';
import { AppModule } from '../../app.module';
import { ConfigService } from '@nestjs/config';
import { execSync } from 'child_process';

/**
 * Helper function to ensure agent responses don't leak internal thought processes
 */
function expectNoAgentThoughtProcess(reply: string) {
  // Check for common agent thought process patterns
  const thoughtProcessPatterns = [
    /\bthought:\b/i,
    /\baction:\b/i,
    /\bobservation:\b/i,
    /\bfinal answer:\b/i,
    /\binvoking\b/i,
    /\btool:\b/i,
    /\bcalling agent\b/i,
    /\bagent\s+thinking\b/i,
    /\binternal process\b/i,
    /\bdebug\b/i,
    /\bfunction call\b/i
  ];

  for (const pattern of thoughtProcessPatterns) {
    expect(reply).not.toMatch(pattern);
  }
}

/**
 * Agent Integration Test Suite
 * 
 * This test suite verifies that all agents are working correctly:
 * - Time agent
 * - Weather agent
 * - Research agent
 * - Document agent
 * - General agent with topic filtering
 * 
 * It uses real HTTP requests to test the API endpoints and verifies the response formats.
 */
describe('Agent Integration Tests', () => {
  let app: INestApplication;
  let configService: ConfigService;
  let browserSessionId: string;
  const testLogger = new Logger('AgentTests');
  
  // Use both cookies paths for testing persistent sessions
  const cookiePath = path.join(process.cwd(), 'cookies.txt');
  const cookiePathNew = path.join(process.cwd(), 'cookies_new.txt');
  
  beforeAll(async () => {
    // Create the Nest application
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
    
    configService = app.get<ConfigService>(ConfigService);
    
    // Check if the cookies already exist and can be reused
    let existingSessionCookie = '';
    try {
      if (fs.existsSync(cookiePath)) {
        const cookieContent = fs.readFileSync(cookiePath, 'utf8');
        const match = cookieContent.match(/browserSessionId=([^;]+)/);
        if (match && match[1]) {
          existingSessionCookie = match[1];
          browserSessionId = existingSessionCookie;
          testLogger.log('Reusing existing session from cookies.txt');
        }
      }
    } catch (e) {
      testLogger.error('Error reading existing cookie file:', e.message);
    }
    
    // If no existing cookie, create a new session
    if (!existingSessionCookie) {
      testLogger.log('Creating new test session...');
      const res = await request(app.getHttpServer())
        .post('/chat/new')
        .expect(201);
      
      // Extract and store the session cookie
      const cookies = res.headers['set-cookie'];
      if (cookies && Array.isArray(cookies) && cookies.length > 0) {
        const sessionCookie = cookies.find(cookie => cookie.includes('browserSessionId'));
        if (sessionCookie) {
          browserSessionId = sessionCookie.split(';')[0].split('=')[1];
          
          // Create Netscape cookie format for curl compatibility
          const cookieContent = `# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_localhost\tFALSE\t/\tFALSE\t${Math.floor(Date.now()/1000) + 86400*30}\tbrowserSessionId\t${browserSessionId}`;
          
          // Save to both cookie files for testing
          fs.writeFileSync(cookiePath, cookieContent);
          fs.writeFileSync(cookiePathNew, cookieContent);
          
          testLogger.log(`Created new session: ${browserSessionId}`);
        }
      }
    }
    
    if (!browserSessionId) {
      throw new Error('Failed to obtain or create browser session ID');
    }
  });

  afterAll(async () => {
    // Don't delete the cookie files, we want to keep them for persistent testing
    // instead we'll let them expire naturally or be overwritten on the next test
    await app.close();
  });

  describe('Chat API Tests', () => {
    // Helper function to send a chat message and check basic response structure
    const sendChatMessage = async (message: string, shouldLog = true) => {
      if (shouldLog) {
        testLogger.log(`Testing: "${message}"`);
      }
      
      const response = await request(app.getHttpServer())
        .post('/chat')
        .set('Cookie', [`browserSessionId=${browserSessionId}`])
        .send({ message })
        .expect(201);
      
      expect(response.body).toBeDefined();
      expect(response.body.reply).toBeDefined();
      expect(typeof response.body.reply).toBe('string');
      
      if (shouldLog) {
        testLogger.log(`Response: "${response.body.reply.substring(0, 100)}${response.body.reply.length > 100 ? '...' : ''}"`);
      }
      
      return response.body.reply;
    };
    
    // Helper to test responses for agent thought process leakage
    const expectNoAgentThoughtProcess = (reply: string) => {
      expect(reply).not.toContain('THOUGHT:');
      expect(reply).not.toContain('ACTION:');
      expect(reply).not.toContain('OBSERVATION:');
      expect(reply).not.toContain('Executing web_search');
      expect(reply).not.toContain('I need to search');
      expect(reply).not.toContain('Let me search');
    };

    it('should return history', async () => {
      const res = await request(app.getHttpServer())
        .get('/chat/history')
        .set('Cookie', [`browserSessionId=${browserSessionId}`])
        .expect(200);
      
      expect(Array.isArray(res.body)).toBeTruthy();
    });

    // Time agent tests
    describe('Time Agent Tests', () => {
      it('should correctly respond to time questions', async () => {
        const reply = await sendChatMessage('What time is it in Santo Domingo, Dominican Republic?');
        
        // Should contain time information and location reference
        expect(reply.toLowerCase()).toMatch(/\b(time|santo domingo|dominican|tuesday|july)\b/);
        expectNoAgentThoughtProcess(reply);
      }, 30000);

      it('should handle time in other locations', async () => {
        const reply = await sendChatMessage('What time is in Bangkok, Thailand?');
        
        expect(reply).toContain('time in Bangkok');
        expect(reply).toContain('Thailand');
        expectNoAgentThoughtProcess(reply);
      }, 30000);

      it('should compare times between different locations', async () => {
        const reply = await sendChatMessage('Tell me the current time in Santo Domingo, Dominican Republic and compare it with the current time in Buenos Aires, Argentina');
        
        expect(reply).toContain('Santo Domingo');
        expect(reply).toContain('Buenos Aires');
        expectNoAgentThoughtProcess(reply);
      }, 30000);
      
      // Test time agent via curl to verify cookie handling works
      it('should respond to time questions via curl with cookies', async () => {
        try {
          const curlCommand = `curl -s -X POST http://localhost:3000/chat -H "Content-Type: application/json" -d '{"message": "What time is it in Paris?"}' -b ${cookiePath} -c ${cookiePath}`;
          const result = execSync(curlCommand).toString();
          const jsonResult = JSON.parse(result);
          
          expect(jsonResult.reply).toBeDefined();
          expect(jsonResult.reply).toContain('Paris');
          expectNoAgentThoughtProcess(jsonResult.reply);
          
          testLogger.log(`Curl test passed: ${jsonResult.reply.substring(0, 50)}...`);
        } catch (error) {
          testLogger.error('Curl command failed:', error.message);
          // Don't fail the test if curl fails, as it might be an environment issue
          // The other tests should still validate the functionality
          console.warn('Curl test skipped due to execution error');
        }
      });
    });

    // Weather agent tests
    describe('Weather Agent Tests', () => {
      it('should correctly respond to weather questions', async () => {
        const reply = await sendChatMessage('How\'s the weather in Santo Domingo, Dominican Republic?');
        
        expect(reply.toLowerCase()).toContain('weather');
        expect(reply).toContain('Santo Domingo');
        expectNoAgentThoughtProcess(reply);
      }, 30000);
      
      it('should respond to weather questions for other locations', async () => {
        const reply = await sendChatMessage('What\'s the weather like in Tokyo, Japan?');
        
        expect(reply.toLowerCase()).toContain('weather');
        expect(reply).toContain('Tokyo');
        expectNoAgentThoughtProcess(reply);
      }, 30000);
      
      // Test weather agent via curl to verify cookie handling works
      it('should respond to weather questions via curl with cookies', async () => {
        try {
          const curlCommand = `curl -s -X POST http://localhost:3000/chat -H "Content-Type: application/json" -d '{"message": "How is the weather in London?"}' -b ${cookiePathNew} -c ${cookiePathNew}`;
          const result = execSync(curlCommand).toString();
          const jsonResult = JSON.parse(result);
          
          expect(jsonResult.reply).toBeDefined();
          expect(jsonResult.reply.toLowerCase()).toContain('weather');
          expect(jsonResult.reply).toContain('London');
          expectNoAgentThoughtProcess(jsonResult.reply);
          
          testLogger.log(`Curl weather test passed: ${jsonResult.reply.substring(0, 50)}...`);
        } catch (error) {
          testLogger.error('Curl weather command failed:', error.message);
          // Don't fail the test if curl fails, as it might be an environment issue
        }
      });
    });

    // Research agent tests
    describe('Research Agent Tests', () => {
      it('should correctly research company founding information', async () => {
        const reply = await sendChatMessage('When was Soluciones GBH founded?');
        
        // The company was founded in 2004
        expect(reply).toMatch(/\b(2004|founded|established)\b/i);
        expectNoAgentThoughtProcess(reply);
      }, 30000);

      it('should handle follow-up questions', async () => {
        const reply = await sendChatMessage('Who founded it?');
        
        // Should provide some founding information
        expect(reply.toLowerCase()).toMatch(/\b(founder|founded|established|amazon|jeff|bezos)\b/i);
        expectNoAgentThoughtProcess(reply);
      }, 30000);
      
      it('should handle questions about company location', async () => {
        const reply = await sendChatMessage('Where is GBH located?');
        
        // Should provide location information
        expect(reply.toLowerCase()).toMatch(/\b(located|boston|massachusetts|location|address)\b/i);
        expectNoAgentThoughtProcess(reply);
      }, 30000);
      
      it('should test research for other company information', async () => {
        // Test with another company - let's use Microsoft
        const reply = await sendChatMessage('When was Microsoft founded and by whom?');
        
        expect(reply).toMatch(/\b(1975|bill gates|paul allen)\b/i);
        expectNoAgentThoughtProcess(reply);
      }, 30000);
      
      // Test research agent via curl to verify cookie handling works
      it('should research via curl with cookies', async () => {
        try {
          const curlCommand = `curl -s -X POST http://localhost:3000/chat -H "Content-Type: application/json" -d '{"message": "What year was Google founded?"}' -b ${cookiePath} -c ${cookiePath}`;
          const result = execSync(curlCommand).toString();
          const jsonResult = JSON.parse(result);
          
          expect(jsonResult.reply).toBeDefined();
          expect(jsonResult.reply).toMatch(/\b(1998|google|founded)\b/i);
          expectNoAgentThoughtProcess(jsonResult.reply);
          
          testLogger.log(`Curl research test passed: ${jsonResult.reply.substring(0, 50)}...`);
        } catch (error) {
          testLogger.error('Curl research command failed:', error.message);
        }
      }, 30000);
    });

    // Topic filtering tests
    describe('Topic Filtering Tests', () => {
      // Get the default topic
      const getTopic = () => {
        return configService.get<string>('CHAT_DEFAULT_TOPIC') || 'No topic';
      };

      it('should accept questions related to the default topic', async () => {
        const topic = getTopic();
        testLogger.log(`Current topic restriction: ${topic}`);
        
        if (topic !== 'No topic') {
          const reply = await sendChatMessage(`Talk me about ${topic}`);
          
          expect(reply).not.toContain('not related to');
          expect(reply).not.toContain('cannot assist with');
          expectNoAgentThoughtProcess(reply);
        }
      });
      
      it('should provide information about Dominican food recipes if that is the topic', async () => {
        const topic = getTopic();
        if (topic?.toLowerCase() === 'dominican food') {
          const reply = await sendChatMessage('How do I cook mangú?');
          
          expect(reply.toLowerCase()).toContain('mangú');
          expect(reply.toLowerCase()).toMatch(/\b(plantain|plátano)\b/i);
          expect(reply).not.toContain('not related to');
          expectNoAgentThoughtProcess(reply);
        } else {
          testLogger.log(`Skipping mangú test as topic is not Dominican Food`);
        }
      });

      it('should reject questions not related to the default topic if topic filtering is enabled', async () => {
        const topic = getTopic();
        if (topic !== 'No topic') {
          const unrelatedTopic = topic === 'Dominican Food' ? 'beisbol' : 'Quantum Physics';
          const reply = await sendChatMessage(`Talk me about ${unrelatedTopic}`);
          
          // If topic filtering is enabled, it should refuse
          if (reply.toLowerCase().includes('not related to') || 
              reply.toLowerCase().includes('cannot assist with')) {
            expect(reply.toLowerCase()).toMatch(new RegExp(`\\b${topic.toLowerCase()}\\b`));
          }
          
          expectNoAgentThoughtProcess(reply);
        }
      });
      
      // Test topic filtering via curl to verify cookie handling works
      it('should enforce topic filtering via curl with cookies', async () => {
        const topic = getTopic();
        if (topic !== 'No topic') {
          try {
            const curlCommand = `curl -s -X POST http://localhost:3000/chat -H "Content-Type: application/json" -d '{"message": "Tell me about ${topic}"}' -b ${cookiePathNew} -c ${cookiePathNew}`;
            const result = execSync(curlCommand).toString();
            const jsonResult = JSON.parse(result);
            
            expect(jsonResult.reply).toBeDefined();
            expect(jsonResult.reply).not.toContain('not related to');
            expectNoAgentThoughtProcess(jsonResult.reply);
            
            testLogger.log(`Curl topic test passed: ${jsonResult.reply.substring(0, 50)}...`);
          } catch (error) {
            testLogger.error('Curl topic command failed:', error.message);
          }
        }
      });
    });
  });

  describe('Document Agent Tests', () => {
    let pdfUploaded = false;
    
    it('should upload and process a PDF document', async () => {
      const pdfPath = path.join(process.cwd(), 'sample_account_details.pdf');
      
      // Skip if the PDF doesn't exist
      if (!fs.existsSync(pdfPath)) {
        testLogger.warn('sample_account_details.pdf not found, skipping document tests');
        return;
      }

      try {
        const response = await request(app.getHttpServer())
          .post('/chat/upload')
          .set('Cookie', [`browserSessionId=${browserSessionId}`])
          .attach('file', pdfPath)
          .field('message', 'What is this document about?');

        // Document tests may fail due to ChromaDB issues in test environment - that's okay
        if (response.status === 201) {
          expect(response.body).toBeDefined();
          expect(response.body.filename).toBeDefined();
          
          if (response.body.answer) {
            expect(response.body.answer).toContain('account');
          }
          
          pdfUploaded = true;
          testLogger.log('PDF upload succeeded');
        } else {
          testLogger.warn('PDF upload returned status code', response.status);
        }
      } catch (error) {
        testLogger.warn('Error in PDF upload test:', error.message);
      }
    }, 30000);

    it('should answer questions about the uploaded document', async () => {
      if (!pdfUploaded) {
        testLogger.warn('PDF was not uploaded successfully, skipping document question test');
        return;
      }

      const response = await request(app.getHttpServer())
        .post('/chat')
        .set('Cookie', [`browserSessionId=${browserSessionId}`])
        .send({ message: 'What is this document about?' })
        .expect(201);
      
      const reply = response.body.reply;
      expect(reply).toMatch(/\b(account|bank|details)\b/i);
      expectNoAgentThoughtProcess(reply);
    }, 20000);

    it('should describe document details', async () => {
      if (!pdfUploaded) {
        testLogger.warn('PDF was not uploaded successfully, skipping document details test');
        return;
      }

      const response = await request(app.getHttpServer())
        .post('/chat')
        .set('Cookie', [`browserSessionId=${browserSessionId}`])
        .send({ message: 'What details does it have?' })
        .expect(201);
      
      const reply = response.body.reply;
      expect(reply).toMatch(/\b(account|bank|details)\b/i);
      expectNoAgentThoughtProcess(reply);
    }, 20000);

    it('should extract specific information about ACH routing', async () => {
      if (!pdfUploaded) {
        testLogger.warn('PDF was not uploaded successfully, skipping document extraction test');
        return;
      }

      const response = await request(app.getHttpServer())
        .post('/chat')
        .set('Cookie', [`browserSessionId=${browserSessionId}`])
        .send({ message: 'What is the ACH route in the file?' })
        .expect(201);
      
      const reply = response.body.reply;
      // The ACH route should be in the document
      expect(reply).toMatch(/\b\d{8,}\b/);  // Match numeric routing number
      expectNoAgentThoughtProcess(reply);
    }, 20000);
    
    it('should extract information about the bank in the file', async () => {
      if (!pdfUploaded) {
        testLogger.warn('PDF was not uploaded successfully, skipping bank name extraction test');
        return;
      }

      const response = await request(app.getHttpServer())
        .post('/chat')
        .set('Cookie', [`browserSessionId=${browserSessionId}`])
        .send({ message: 'What is the bank in the file?' })
        .expect(201);
      
      const reply = response.body.reply;
      expect(reply).toMatch(/\b(bank|financial institution)\b/i);
      expectNoAgentThoughtProcess(reply);
    }, 20000);
    
    // Test document agent via curl to verify cookie handling works
    it('should answer document questions via curl with cookies', async () => {
      if (!pdfUploaded) {
        testLogger.warn('PDF was not uploaded successfully, skipping curl document test');
        return;
      }
      
      try {
        const curlCommand = `curl -s -X POST http://localhost:3000/chat -H "Content-Type: application/json" -d '{"message": "What type of document did I upload?"}' -b ${cookiePath} -c ${cookiePath}`;
        const result = execSync(curlCommand).toString();
        const jsonResult = JSON.parse(result);
        
        expect(jsonResult.reply).toBeDefined();
        expect(jsonResult.reply).toMatch(/\b(account|bank|document|details)\b/i);
        expectNoAgentThoughtProcess(jsonResult.reply);
        
        testLogger.log(`Curl document test passed: ${jsonResult.reply.substring(0, 50)}...`);
      } catch (error) {
        testLogger.error('Curl document command failed:', error.message);
      }
    }, 20000);
  });
});

/**
 * Individual Agent Test Suite
 * 
 * This test suite directly tests each agent's handle function to ensure
 * they respond correctly to specific inputs.
 */
/**
 * Individual Agent Test Suite
 * 
 * This test suite directly tests each agent's handle function to ensure
 * they respond correctly to specific inputs.
 */
describe('Individual Agent Tests', () => {
  // Import the AgentRegistry here to ensure all agents are registered
  const { AgentRegistry } = require('../agent-registry');
  const testLogger = new Logger('AgentDirectTests');
  
  // Helper to test responses for agent thought process leakage
  const expectNoAgentThoughtProcess = (reply: string) => {
    expect(reply).not.toContain('THOUGHT:');
    expect(reply).not.toContain('ACTION:');
    expect(reply).not.toContain('OBSERVATION:');
    expect(reply).not.toContain('Executing web_search');
    expect(reply).not.toContain('I need to search');
    expect(reply).not.toContain('Let me search');
  };
  
  // Test if all required agents exist in the registry
  describe('Agent Registry', () => {
    it('should have all required agents registered', () => {
      // Critical agents that must exist
      const requiredAgents = [
        'web_search',
        'time', 
        'open_weather_map',
        'research',
        'summarizer',
        'document_search'
      ];
      
      requiredAgents.forEach(agentName => {
        const agent = AgentRegistry.getAgent(agentName);
        expect(agent).toBeDefined();
        testLogger.log(`Agent '${agentName}' is registered`);
      });
      
      // Log all available agents
      const allAgents = AgentRegistry.getAllAgents();
      testLogger.log(`Total agents registered: ${allAgents.length}`);
      allAgents.forEach(agent => {
        testLogger.log(`- ${agent.name}: ${agent.description.substring(0, 50)}...`);
      });
    });
  });
  
  describe('Research Agent', () => {
    it('should respond to research questions', async () => {
      const agent = AgentRegistry.getAgent('research');
      expect(agent).toBeDefined();
      
      if (agent) {
        const result = await agent.handle(
          'When was Apple founded?', 
          {}, 
          AgentRegistry.callAgent
        );
        
        expect(result.output).toBeDefined();
        expect(result.output).toMatch(/\b(1976|apple)\b/i);
        expectNoAgentThoughtProcess(result.output);
        testLogger.log(`Research agent output: "${result.output.substring(0, 50)}..."`);
      }
    }, 30000);
    
    it('should handle follow-up questions with context', async () => {
      const agent = AgentRegistry.getAgent('research');
      expect(agent).toBeDefined();
      
      if (agent) {
        // Create mock chat history for context
        const mockContext = {
          chatHistory: [
            { role: 'user', content: 'When was Soluciones GBH founded?' },
            { role: 'assistant', content: 'Soluciones GBH was founded in 2004 in the Dominican Republic.' }
          ]
        };
        
        const result = await agent.handle(
          'Who founded it?',
          mockContext,
          AgentRegistry.callAgent
        );
        
        expect(result.output).toBeDefined();
        expect(result.output.toLowerCase()).toMatch(/\b(founder|founded|established|creator)\b/i);
        expectNoAgentThoughtProcess(result.output);
        testLogger.log(`Research follow-up output: "${result.output.substring(0, 50)}..."`);
      }
    }, 30000);
  });
  
  describe('Time Agent', () => {
    it('should respond to time questions', async () => {
      // This is testing the intelligent time agent in the registry
      const result = await AgentRegistry.callAgent(
        'time',
        'What time is it in New York?',
        {}
      );
      
      expect(result.output).toBeDefined();
      expect(result.output).toMatch(/\b(time|current|new york)\b/i);
      expectNoAgentThoughtProcess(result.output);
      testLogger.log(`Time agent output: "${result.output}"`);
    });
    
    it('should handle multiple time zones', async () => {
      const result = await AgentRegistry.callAgent(
        'time',
        'What time is it in Tokyo?',
        {}
      );
      
      expect(result.output).toBeDefined();
      expect(result.output).toMatch(/\b(time|current|tokyo)\b/i);
      expectNoAgentThoughtProcess(result.output);
    });
  });
  
  describe('Weather Agent', () => {
    it('should respond to weather questions', async () => {
      // This is testing the built-in agent in the registry
      const result = await AgentRegistry.callAgent(
        'open_weather_map',
        'New York',
        {}
      );
      
      expect(result.output).toBeDefined();
      expect(result.output).toMatch(/\b(weather|temperature|new york)\b/i);
      expectNoAgentThoughtProcess(result.output);
      testLogger.log(`Weather agent output: "${result.output}"`);
    });
    
    it('should handle weather for international locations', async () => {
      const result = await AgentRegistry.callAgent(
        'open_weather_map',
        'Tokyo, Japan',
        {}
      );
      
      expect(result.output).toBeDefined();
      expect(result.output).toMatch(/\b(weather|temperature|tokyo)\b/i);
      expectNoAgentThoughtProcess(result.output);
    });
  });
  
  describe('Summarizer Agent', () => {
    it('should summarize text correctly', async () => {
      const agent = AgentRegistry.getAgent('summarizer');
      expect(agent).toBeDefined();
      
      if (agent) {
        const result = await agent.handle(
          'This is a test text that needs to be summarized. It contains some information about testing NestJS applications. The tests should verify that all components work correctly together.',
          {}, 
          AgentRegistry.callAgent
        );
        
        expect(result.output).toBeDefined();
        expect(result.output).toContain('test');
        expectNoAgentThoughtProcess(result.output);
        testLogger.log(`Summarizer output: "${result.output}"`);
      }
    });
    
    it('should handle complex research prompts', async () => {
      const agent = AgentRegistry.getAgent('summarizer');
      expect(agent).toBeDefined();
      
      if (agent) {
        const complexPrompt = `
USER'S QUESTION: Who founded Microsoft?

SEARCH RESULTS: 
Microsoft Corporation was founded by Bill Gates and Paul Allen on April 4, 1975, in Albuquerque, New Mexico. The company was originally established to develop and sell BASIC interpreters for the Altair 8800. Microsoft rose to dominate the personal computer operating system market with MS-DOS in the mid-1980s, followed by Microsoft Windows.

INSTRUCTIONS:
1. Carefully analyze the search results to find information that directly answers the user's question.
2. Extract specific facts, names, dates, and relevant details.
3. If the search results contain sufficient information to answer the question completely, provide a clear, conversational answer in the same language as the user's question.
4. If the information is incomplete, start your response with "NEED_MORE_SEARCH:"
5. Focus only on factual information from the search results. Do not make assumptions.
6. Provide natural, conversational responses without technical metadata.

RESPONSE:
`;
        
        const result = await agent.handle(
          complexPrompt,
          {}, 
          AgentRegistry.callAgent
        );
        
        expect(result.output).toBeDefined();
        expect(result.output.toLowerCase()).toMatch(/\b(bill gates|paul allen|1975|microsoft)\b/i);
        expectNoAgentThoughtProcess(result.output);
      }
    });
  });
  
  describe('Document Search Agent', () => {
    it('should respond to document questions', async () => {
      const agent = AgentRegistry.getAgent('document_search');
      expect(agent).toBeDefined();
      
      // This agent requires a context with embedding data, so we'll just check it exists
      if (agent) {
        testLogger.log('Document search agent is available');
      }
    });
  });
  
  describe('Web Search Agent', () => {
    it('should respond to web search queries', async () => {
      const result = await AgentRegistry.callAgent(
        'web_search',
        'What is the capital of Japan?',
        {}
      );
      
      expect(result.output).toBeDefined();
      // Handle both string and object outputs
      const outputText = typeof result.output === 'string' ? result.output : JSON.stringify(result.output);
      expect(outputText.length).toBeGreaterThan(10);
      testLogger.log(`Web search output length: ${outputText.length} characters`);
    }, 30000);
  });
});
